## API Report File for "expression-engine"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export type ArrayExpression = Node_2 & ArrayExpression2<Expression | SpreadElement>;

// @public (undocumented)
export interface ArrayExpression2<T = Expression2 | SpreadElement2> {
    // (undocumented)
    elements: T[];
    // (undocumented)
    type: 'ArrayExpression';
}

// @public (undocumented)
export type ArrowFunctionExpression = Node_2 & ArrowFunctionExpression2<Pattern, Expression>;

// @public (undocumented)
export interface ArrowFunctionExpression2<T = Pattern2, T2 = Expression2> {
    // (undocumented)
    body: T2;
    // (undocumented)
    params: T[];
    // (undocumented)
    type: 'ArrowFunctionExpression';
}

// @public (undocumented)
export type AssignmentPattern = Node_2 & AssignmentPattern2<Identifier, Expression>;

// @public (undocumented)
export interface AssignmentPattern2<T = Identifier2, T2 = Expression> {
    // (undocumented)
    left: T;
    // (undocumented)
    right: T2;
    // (undocumented)
    type: 'AssignmentPattern';
}

// @public (undocumented)
export type BinaryExpression = Node_2 & BinaryExpression2<Expression>;

// @public (undocumented)
export interface BinaryExpression2<T = Expression2> {
    // (undocumented)
    left: T;
    // (undocumented)
    operator: BinaryOperator;
    // (undocumented)
    right: T;
    // (undocumented)
    type: 'BinaryExpression';
}

// @public (undocumented)
export type BinaryOperator = '**' | '*' | '/' | '%' | '+' | '-' | '<<' | '>>' | '>>>' | '>' | '<' | '>=' | '<=' | '==' | '!=' | '===' | '!==' | '&' | '^' | '|' | '|>';

// @public (undocumented)
export type BooleanLiteral = Node_2 & BooleanLiteral2;

// @public (undocumented)
export interface BooleanLiteral2 {
    // (undocumented)
    type: 'BooleanLiteral';
    // (undocumented)
    value: boolean;
}

// @public (undocumented)
export type CallExpression = Node_2 & CallExpression2<Expression | SpreadElement, Expression>;

// @public (undocumented)
export interface CallExpression2<T = Expression2 | SpreadElement2, T2 = Expression2> {
    // (undocumented)
    arguments: T[];
    // (undocumented)
    callee: T2;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    type: 'CallExpression';
}

// @public (undocumented)
export type ConditionalExpression = Node_2 & ConditionalExpression2<Expression>;

// @public (undocumented)
export interface ConditionalExpression2<T = Expression2> {
    // (undocumented)
    alternate: T;
    // (undocumented)
    consequent: T;
    // (undocumented)
    test: T;
    // (undocumented)
    type: 'ConditionalExpression';
}

// @public (undocumented)
export interface CustomData {
    // (undocumented)
    add?(right: unknown): unknown;
    // (undocumented)
    added?(left: unknown): unknown;
    // (undocumented)
    divide?(right: unknown): unknown;
    // (undocumented)
    divided?(left: unknown): unknown;
    // (undocumented)
    equal?(value: unknown): unknown;
    // (undocumented)
    greaterThan?(value: unknown): unknown;
    // (undocumented)
    greaterThanOrEqual?(value: unknown): unknown;
    // (undocumented)
    lessThan?(value: unknown): unknown;
    // (undocumented)
    lessThanOrEqual?(value: unknown): unknown;
    // (undocumented)
    multiplied?(left: unknown): unknown;
    // (undocumented)
    multiply?(right: unknown): unknown;
    // (undocumented)
    power?(value: unknown): unknown;
    // (undocumented)
    powered?(value: unknown): unknown;
    // (undocumented)
    remainer?(right: unknown): unknown;
    // (undocumented)
    remainered?(left: unknown): unknown;
    // (undocumented)
    subtract?(right: unknown): unknown;
    // (undocumented)
    subtracted?(left: unknown): unknown;
}

// @public (undocumented)
export const defaultLocale: {
    multipleDecimalPoint: string;
    expect: string;
    unexpectToken: string;
    expectUnaryOperator: string;
    expectConditionalOperator: string;
    invalidPropertyName: string;
    emptyExpression: string;
    invalidFunctionParameter: string;
};

// @public (undocumented)
export interface EOFToken extends Node_2 {
    // (undocumented)
    type: 'EOFToken';
}

// @public (undocumented)
export function evaluateExpression(expression: Expression, context: {
    [name: string]: unknown;
}, locale?: Locale, customData?: Array<{
    new (...args: any[]): unknown;
}> | ((value: unknown) => value is CustomData)): unknown;

// @public (undocumented)
export type Expression = BinaryExpression | MemberExpression | Identifier | NumericLiteral | StringLiteral | ConditionalExpression | CallExpression | LogicalExpression | UnaryExpression | ThisExpression | BooleanLiteral | ArrayExpression | ObjectExpression | NullLiteral | ArrowFunctionExpression | FunctionParamsExpression;

// @public (undocumented)
export type Expression2 = BinaryExpression2 | MemberExpression2 | Identifier2 | NumericLiteral2 | StringLiteral2 | ConditionalExpression2 | CallExpression2 | LogicalExpression2 | UnaryExpression2 | ThisExpression2 | BooleanLiteral2 | ArrayExpression2 | ObjectExpression2 | NullLiteral2 | ArrowFunctionExpression2 | FunctionParamsExpression2;

// @public (undocumented)
export class ExpressionError extends Error {
    constructor(message: string, range: [number, number]);
    // (undocumented)
    range: [number, number];
}

// @public (undocumented)
export type FunctionParamsExpression = Node_2 & FunctionParamsExpression2<Pattern>;

// @public (undocumented)
export interface FunctionParamsExpression2<T = Pattern2> {
    // (undocumented)
    params: T[];
    // (undocumented)
    type: 'FunctionParamsExpression';
}

// @public (undocumented)
export function getLocale(locale: null | undefined | Locale): Locale;

// @public (undocumented)
export type Identifier = Node_2 & Identifier2;

// @public (undocumented)
export interface Identifier2 {
    // (undocumented)
    name: string;
    // (undocumented)
    type: 'Identifier';
}

// @public (undocumented)
export interface KeywordToken extends Node_2 {
    // (undocumented)
    name: string;
    // (undocumented)
    type: 'KeywordToken';
}

// @public (undocumented)
export type Locale = typeof defaultLocale;

// @public (undocumented)
export type LogicalExpression = Node_2 & LogicalExpression2<Expression>;

// @public (undocumented)
export interface LogicalExpression2<T = Expression2> {
    // (undocumented)
    left: T;
    // (undocumented)
    operator: LogicalOperator;
    // (undocumented)
    right: T;
    // (undocumented)
    type: 'LogicalExpression';
}

// @public (undocumented)
export type LogicalOperator = '||' | '&&' | '??';

// @public (undocumented)
export type MemberExpression = Node_2 & MemberExpression2<Expression>;

// @public (undocumented)
export interface MemberExpression2<T = Expression2> {
    // (undocumented)
    object: T;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    property: T;
    // (undocumented)
    type: 'MemberExpression';
}

// @public (undocumented)
interface Node_2 {
    // (undocumented)
    parenthesesRange?: [number, number];
    // (undocumented)
    range: [number, number];
}
export { Node_2 as Node }

// @public (undocumented)
export type NullLiteral = Node_2 & NullLiteral2;

// @public (undocumented)
export interface NullLiteral2 {
    // (undocumented)
    type: 'NullLiteral';
}

// @public (undocumented)
export type NumericLiteral = Node_2 & NumericLiteral2;

// @public (undocumented)
export interface NumericLiteral2 {
    // (undocumented)
    type: 'NumericLiteral';
    // (undocumented)
    value: number;
}

// @public (undocumented)
export type ObjectExpression = Node_2 & ObjectExpression2<Property | SpreadElement>;

// @public (undocumented)
export interface ObjectExpression2<T = Property2 | SpreadElement2> {
    // (undocumented)
    properties: T[];
    // (undocumented)
    type: 'ObjectExpression';
}

// @public (undocumented)
export function parseExpression(tokens: Token[], locale?: Locale): Expression;

// @public (undocumented)
export type Pattern = Identifier | AssignmentPattern | RestElement;

// @public (undocumented)
export type Pattern2 = Identifier2 | AssignmentPattern2 | RestElement2;

// @public (undocumented)
export const postfixUnaryOperators: string[];

// @public (undocumented)
export function printExpression(expression: Expression2, options?: Partial<{
    keepBinaryExpressionOrder: boolean;
}>): string;

// @public (undocumented)
export const priorizedBinaryOperators: string[][];

// @public (undocumented)
export type Property = Node_2 & Property2<NumericLiteral | StringLiteral | Identifier>;

// @public (undocumented)
export interface Property2<T = NumericLiteral2 | StringLiteral2 | Identifier2> {
    // (undocumented)
    key: T;
    // (undocumented)
    shorthand: boolean;
    // (undocumented)
    type: 'Property';
    // (undocumented)
    value: Expression;
}

// @public (undocumented)
export interface PunctuatorToken extends Node_2 {
    // (undocumented)
    type: 'PunctuatorToken';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export function replaceLocaleParameters(locale: string, ...parameters: (number | string)[]): string;

// @public (undocumented)
export type RestElement = Node_2 & RestElement2<Identifier>;

// @public (undocumented)
export interface RestElement2<T = Identifier2> {
    // (undocumented)
    argument: T;
    // (undocumented)
    type: 'RestElement';
}

// @public (undocumented)
export type SpreadElement = Node_2 & SpreadElement2<Expression>;

// @public (undocumented)
export interface SpreadElement2<T = Expression> {
    // (undocumented)
    argument: T;
    // (undocumented)
    type: 'SpreadElement';
}

// @public (undocumented)
export type StringLiteral = Node_2 & StringLiteral2;

// @public (undocumented)
export interface StringLiteral2 {
    // (undocumented)
    type: 'StringLiteral';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export type ThisExpression = Node_2 & ThisExpression2;

// @public (undocumented)
export interface ThisExpression2 {
    // (undocumented)
    type: 'ThisExpression';
}

// @public (undocumented)
export type Token = BooleanLiteral | EOFToken | Identifier | KeywordToken | NumericLiteral | PunctuatorToken | StringLiteral | NullLiteral;

// @public (undocumented)
export function tokenizeExpression(expression: string): Token[];

// @public (undocumented)
export type UnaryExpression = Node_2 & UnaryExpression2<Expression>;

// @public (undocumented)
export interface UnaryExpression2<T = Expression2> {
    // (undocumented)
    argument: T;
    // (undocumented)
    operator: UnaryOperator;
    // (undocumented)
    type: 'UnaryExpression';
}

// @public (undocumented)
export type UnaryOperator = '+' | '-' | '!' | '~' | '%' | 'await';

// (No @packageDocumentation comment for this package)

```
