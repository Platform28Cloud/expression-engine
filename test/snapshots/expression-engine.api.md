## API Report File for "expression-engine"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export interface ArrayExpression extends Node_2 {
    // (undocumented)
    elements: (Expression | SpreadElement)[];
    // (undocumented)
    type: 'ArrayExpression';
}

// @public (undocumented)
export interface ArrowFunctionExpression extends Node_2 {
    // (undocumented)
    body: Expression;
    // (undocumented)
    params: Pattern[];
    // (undocumented)
    type: 'ArrowFunctionExpression';
}

// @public (undocumented)
export interface AssignmentPattern extends Node_2 {
    // (undocumented)
    left: Identifier;
    // (undocumented)
    right: Expression;
    // (undocumented)
    type: 'AssignmentPattern';
}

// @public (undocumented)
export interface BinaryExpression extends Node_2 {
    // (undocumented)
    left: Expression;
    // (undocumented)
    operator: BinaryOperator;
    // (undocumented)
    right: Expression;
    // (undocumented)
    type: 'BinaryExpression';
}

// @public (undocumented)
export type BinaryOperator = '**' | '*' | '/' | '%' | '+' | '-' | '<<' | '>>' | '>>>' | '>' | '<' | '>=' | '<=' | '==' | '!=' | '===' | '!==' | '&' | '^' | '|' | '|>';

// @public (undocumented)
export interface BooleanLiteral extends Node_2 {
    // (undocumented)
    type: 'BooleanLiteral';
    // (undocumented)
    value: boolean;
}

// @public (undocumented)
export interface CallExpression extends Node_2 {
    // (undocumented)
    arguments: (Expression | SpreadElement)[];
    // (undocumented)
    callee: Expression;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    type: 'CallExpression';
}

// @public (undocumented)
export interface ConditionalExpression extends Node_2 {
    // (undocumented)
    alternate: Expression;
    // (undocumented)
    consequent: Expression;
    // (undocumented)
    test: Expression;
    // (undocumented)
    type: 'ConditionalExpression';
}

// @public (undocumented)
export interface CustomData {
    // (undocumented)
    add?(right: unknown): unknown;
    // (undocumented)
    added?(left: unknown): unknown;
    // (undocumented)
    divide?(right: unknown): unknown;
    // (undocumented)
    divided?(left: unknown): unknown;
    // (undocumented)
    equal?(value: unknown): unknown;
    // (undocumented)
    greaterThan?(value: unknown): unknown;
    // (undocumented)
    greaterThanOrEqual?(value: unknown): unknown;
    // (undocumented)
    lessThan?(value: unknown): unknown;
    // (undocumented)
    lessThanOrEqual?(value: unknown): unknown;
    // (undocumented)
    multiplied?(left: unknown): unknown;
    // (undocumented)
    multiply?(right: unknown): unknown;
    // (undocumented)
    power?(value: unknown): unknown;
    // (undocumented)
    powered?(value: unknown): unknown;
    // (undocumented)
    remainer?(right: unknown): unknown;
    // (undocumented)
    remainered?(left: unknown): unknown;
    // (undocumented)
    subtract?(right: unknown): unknown;
    // (undocumented)
    subtracted?(left: unknown): unknown;
}

// @public (undocumented)
export const defaultLocale: {
    multipleDecimalPoint: string;
    expect: string;
    unexpectToken: string;
    expectUnaryOperator: string;
    expectConditionalOperator: string;
    invalidPropertyName: string;
    emptyExpression: string;
    invalidFunctionParameter: string;
};

// @public (undocumented)
export interface EOFToken extends Node_2 {
    // (undocumented)
    type: 'EOFToken';
}

// @public (undocumented)
export function evaluateExpression(expression: Expression, context: {
    [name: string]: unknown;
}, locale?: Locale, customData?: Array<{
    new (...args: any[]): unknown;
}> | ((value: unknown) => value is CustomData)): unknown;

// @public (undocumented)
export type Expression = BinaryExpression | MemberExpression | Identifier | NumericLiteral | StringLiteral | ConditionalExpression | CallExpression | LogicalExpression | UnaryExpression | ThisExpression | BooleanLiteral | ArrayExpression | ObjectExpression | NullLiteral | ArrowFunctionExpression | FunctionParamsExpression;

// @public (undocumented)
export class ExpressionError extends Error {
    constructor(message: string, range: [number, number]);
    // (undocumented)
    range: [number, number];
}

// @public (undocumented)
export interface FunctionParamsExpression extends Node_2 {
    // (undocumented)
    params: Pattern[];
    // (undocumented)
    type: 'FunctionParamsExpression';
}

// @public (undocumented)
export function getLocale(locale: null | undefined | Locale): Locale;

// @public (undocumented)
export interface Identifier extends Node_2 {
    // (undocumented)
    name: string;
    // (undocumented)
    type: 'Identifier';
}

// @public (undocumented)
export interface KeywordToken extends Node_2 {
    // (undocumented)
    name: string;
    // (undocumented)
    type: 'KeywordToken';
}

// @public (undocumented)
export type Locale = typeof defaultLocale;

// @public (undocumented)
export interface LogicalExpression extends Node_2 {
    // (undocumented)
    left: Expression;
    // (undocumented)
    operator: LogicalOperator;
    // (undocumented)
    right: Expression;
    // (undocumented)
    type: 'LogicalExpression';
}

// @public (undocumented)
export type LogicalOperator = '||' | '&&' | '??';

// @public (undocumented)
export interface MemberExpression extends Node_2 {
    // (undocumented)
    object: Expression;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    property: Expression;
    // (undocumented)
    type: 'MemberExpression';
}

// @public (undocumented)
interface Node_2 {
    // (undocumented)
    parenthesesRange?: [number, number];
    // (undocumented)
    range: [number, number];
}
export { Node_2 as Node }

// @public (undocumented)
export interface NullLiteral extends Node_2 {
    // (undocumented)
    type: 'NullLiteral';
}

// @public (undocumented)
export interface NumericLiteral extends Node_2 {
    // (undocumented)
    type: 'NumericLiteral';
    // (undocumented)
    value: number;
}

// @public (undocumented)
export interface ObjectExpression extends Node_2 {
    // (undocumented)
    properties: (Property | SpreadElement)[];
    // (undocumented)
    type: 'ObjectExpression';
}

// @public (undocumented)
export function parseExpression(tokens: Token[], locale?: Locale): Expression;

// @public (undocumented)
export type Pattern = Identifier | AssignmentPattern | RestElement;

// @public (undocumented)
export const postfixUnaryOperators: string[];

// @public (undocumented)
export function printExpression(expression: Expression, options?: Partial<{
    keepBinaryExpressionOrder: boolean;
}>): string;

// @public (undocumented)
export const priorizedBinaryOperators: string[][];

// @public (undocumented)
export interface Property extends Node_2 {
    // (undocumented)
    key: NumericLiteral | StringLiteral | Identifier;
    // (undocumented)
    shorthand: boolean;
    // (undocumented)
    type: 'Property';
    // (undocumented)
    value: Expression;
}

// @public (undocumented)
export interface PunctuatorToken extends Node_2 {
    // (undocumented)
    type: 'PunctuatorToken';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export function replaceLocaleParameters(locale: string, ...parameters: (number | string)[]): string;

// @public (undocumented)
export interface RestElement extends Node_2 {
    // (undocumented)
    argument: Identifier;
    // (undocumented)
    type: 'RestElement';
}

// @public (undocumented)
export interface SpreadElement extends Node_2 {
    // (undocumented)
    argument: Expression;
    // (undocumented)
    type: 'SpreadElement';
}

// @public (undocumented)
export interface StringLiteral extends Node_2 {
    // (undocumented)
    type: 'StringLiteral';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export interface ThisExpression extends Node_2 {
    // (undocumented)
    type: 'ThisExpression';
}

// @public (undocumented)
export type Token = BooleanLiteral | EOFToken | Identifier | KeywordToken | NumericLiteral | PunctuatorToken | StringLiteral | NullLiteral;

// @public (undocumented)
export function tokenizeExpression(expression: string): Token[];

// @public (undocumented)
export interface UnaryExpression extends Node_2 {
    // (undocumented)
    argument: Expression;
    // (undocumented)
    operator: UnaryOperator;
    // (undocumented)
    type: 'UnaryExpression';
}

// @public (undocumented)
export type UnaryOperator = '+' | '-' | '!' | '~' | '%' | 'await';

// (No @packageDocumentation comment for this package)

```
